# generated by ChatGPT


from math import sqrt
from .base_tool import BaseTool
from .tool_registry import register_tool


@register_tool("LinearAlgebraTool")
class LinearAlgebraTool(BaseTool):
    """
    Tool providing simple linear algebra operations implemented with base Python.
    Supports matrix addition, transpose, determinant (2x2 or 3x3),
    and eigenvalues for 2x2 matrices.
    """

    def __init__(self, tool_config=None):
        super().__init__(tool_config)

    def run(self, arguments):
        op = arguments.get("operation")
        matrix = arguments.get("matrix")
        matrix_b = arguments.get("matrix_b")  # optional for addition
        if not op or not matrix:
            return {"error": "`operation` and `matrix` are required parameters."}

        if op == "add":
            if not matrix_b:
                return {"error": "`matrix_b` required for addition."}
            return {"result": self.add(matrix, matrix_b)}
        elif op == "transpose":
            return {"result": self.transpose(matrix)}
        elif op == "determinant":
            return {"result": self.determinant(matrix)}
        elif op == "eigenvalues":
            return {"result": self.eigenvalues_2x2(matrix)}
        else:
            return {"error": f"Unsupported operation: {op}"}

    # ---------------- Core math methods ----------------

    def add(self, A, B):
        if len(A) != len(B) or len(A[0]) != len(B[0]):
            return "Matrices must have the same dimensions."
        return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]

    def transpose(self, A):
        return [[A[j][i] for j in range(len(A))] for i in range(len(A[0]))]

    def determinant(self, A):
        n = len(A)
        if n == 2:
            return A[0][0] * A[1][1] - A[0][1] * A[1][0]
        elif n == 3:
            return (
                A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1])
                - A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0])
                + A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0])
            )
        else:
            return "Only 2x2 and 3x3 determinants supported."

    def eigenvalues_2x2(self, A):
        if len(A) != 2 or len(A[0]) != 2:
            return "Eigenvalues only supported for 2x2 matrices."
        a, b = A[0]
        c, d = A[1]
        trace = a + d
        det = a * d - b * c
        discriminant = trace ** 2 - 4 * det
        if discriminant >= 0:
            sqrt_disc = sqrt(discriminant)
            lambda1 = (trace + sqrt_disc) / 2
            lambda2 = (trace - sqrt_disc) / 2
            return [lambda1, lambda2]
        else:
            # complex eigenvalues (return as dicts)
            real = trace / 2
            imag = sqrt(-discriminant) / 2
            return [
                {"real": real, "imag": imag},
                {"real": real, "imag": -imag},
            ]
