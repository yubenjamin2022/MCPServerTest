# generated by ChatGPT

from math import sqrt, isclose
from .base_tool import BaseTool
from .tool_registry import register_tool


@register_tool("MatrixAnalysisTool")
class MatrixAnalysisTool(BaseTool):
    """
    Provides base-Python implementations for fundamental linear algebra operations.
    Includes eigenvalue/eigenvector computation (2x2), matrix inverse, rank, and more.
    """

    def __init__(self, config=None):
        super().__init__(config)

    def run(self, args):
        action = args.get("action")
        mat = args.get("matrix")
        other = args.get("other")

        if not action or not mat:
            return {"error": "`action` and `matrix` parameters are required."}

        try:
            if action == "sum":
                return {"output": self.add_matrices(mat, other)}
            elif action == "flip":
                return {"output": self.transpose_matrix(mat)}
            elif action == "det":
                return {"output": self.calculate_determinant(mat)}
            elif action == "eigvals":
                return {"output": self.compute_eigenvalues(mat)}
            elif action == "eigvecs":
                return {"output": self.compute_eigenvectors(mat)}
            elif action == "inverse":
                return {"output": self.inverse_matrix(mat)}
            elif action == "rank":
                return {"output": self.matrix_rank(mat)}
            else:
                return {"error": f"Unknown action `{action}`."}
        except Exception as e:
            return {"error": str(e)}

    # ---------------- Linear algebra methods ----------------

    def add_matrices(self, A, B):
        if not B:
            return "Second matrix required for addition."
        if len(A) != len(B) or len(A[0]) != len(B[0]):
            return "Matrices must have the same size."
        result = []
        for i in range(len(A)):
            row = [A[i][j] + B[i][j] for j in range(len(A[0]))]
            result.append(row)
        return result

    def transpose_matrix(self, A):
        rows, cols = len(A), len(A[0])
        return [[A[r][c] for r in range(rows)] for c in range(cols)]

    def calculate_determinant(self, A):
        n = len(A)
        if n == 1:
            return A[0][0]
        elif n == 2:
            return A[0][0] * A[1][1] - A[0][1] * A[1][0]
        elif n == 3:
            a, b, c = A[0]
            d, e, f = A[1]
            g, h, i = A[2]
            return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g)
        else:
            # simple recursive Laplace expansion (slow for large n)
            det = 0
            for col in range(n):
                minor = [row[:col] + row[col+1:] for row in A[1:]]
                det += ((-1)**col) * A[0][col] * self.calculate_determinant(minor)
            return det

    def compute_eigenvalues(self, A):
        if len(A) != 2 or len(A[0]) != 2:
            return "Only 2x2 matrices supported."
        a, b = A[0]
        c, d = A[1]
        trace = a + d
        det = a*d - b*c
        delta = trace**2 - 4*det
        if delta >= 0:
            sqrtdelta = sqrt(delta)
            return [(trace + sqrtdelta)/2, (trace - sqrtdelta)/2]
        else:
            re, im = trace/2, sqrt(-delta)/2
            return [{"real": re, "imag": im}, {"real": re, "imag": -im}]

    def compute_eigenvectors(self, A):
        """Compute eigenvectors for a 2x2 real matrix (real eigenvalues only)."""
        vals = self.compute_eigenvalues(A)
        if isinstance(vals[0], dict):
            return "Complex eigenvectors not supported."
        a, b = A[0]
        c, d = A[1]
        vecs = []
        for lam in vals:
            # Solve (A - lambda*I)v = 0
            m = [[a - lam, b], [c, d - lam]]
            if abs(m[0][0]) > abs(m[1][1]):
                v = [m[0][1], -m[0][0]]
            else:
                v = [-m[1][1], m[1][0]]
            norm = sqrt(v[0]**2 + v[1]**2)
            if not isclose(norm, 0):
                v = [x / norm for x in v]
            vecs.append(v)
        return vecs

    def inverse_matrix(self, A):
        n = len(A)
        if n != len(A[0]):
            return "Matrix must be square."
        det = self.calculate_determinant(A)
        if isclose(det, 0):
            return "Matrix is singular; no inverse."

        if n == 2:
            a, b = A[0]
            c, d = A[1]
            return [[d/det, -b/det], [-c/det, a/det]]

        # For 3x3, use adjugate method
        cofactors = []
        for r in range(n):
            cofactor_row = []
            for c in range(n):
                minor = [row[:c] + row[c+1:] for i, row in enumerate(A) if i != r]
                cofactor_row.append(((-1)**(r+c)) * self.calculate_determinant(minor))
            cofactors.append(cofactor_row)
        adjugate = self.transpose_matrix(cofactors)
        return [[adjugate[i][j]/det for j in range(n)] for i in range(n)]

    def matrix_rank(self, A):
        """Compute rank by Gaussian elimination (base Python)."""
        mat = [row[:] for row in A]
        rows, cols = len(mat), len(mat[0])
        rank = 0
        for col in range(cols):
            pivot_row = None
            for r in range(rank, rows):
                if not isclose(mat[r][col], 0):
                    pivot_row = r
                    break
            if pivot_row is None:
                continue
            mat[rank], mat[pivot_row] = mat[pivot_row], mat[rank]
            pivot = mat[rank][col]
            mat[rank] = [x / pivot for x in mat[rank]]
            for r in range(rows):
                if r != rank:
                    factor = mat[r][col]
                    mat[r] = [mat[r][c] - factor * mat[rank][c] for c in range(cols)]
            rank += 1
        return rank
